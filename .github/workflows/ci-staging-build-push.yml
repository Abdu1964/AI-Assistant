name: CI - Build, Validate and Push AI-Assistant (Staging Only)

on:
  push:
    branches: [ staging ]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [staging]

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}

jobs:
  build-and-validate-assistant:
    runs-on: ubuntu-latest

    outputs:
      validation-status: ${{ steps.validate-container.outcome }}
      image-tag: ${{ steps.set-image-tag.outputs.image-tag }}
      docker-pushed: ${{ steps.deployment-trigger.outputs.docker_pushed }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
     
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
     
    - name: Login to Docker Hub
      if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Create .env file
      run: |
        echo "=== Creating .env file from GitHub Secrets ==="
        # Port Configuration
        echo "FLASK_HOST_PORT=${{ secrets.FLASK_HOST_PORT }}" >> .env
        echo "FLASK_INTERNAL_PORT=${{ secrets.FLASK_INTERNAL_PORT }}" >> .env
        echo "REDIS_HOST_PORT=${{ secrets.REDIS_HOST_PORT }}" >> .env
        echo "REDIS_INTERNAL_PORT=${{ secrets.REDIS_INTERNAL_PORT }}" >> .env
        echo "MONGODB_HOST_PORT=${{ secrets.MONGODB_HOST_PORT }}" >> .env
        echo "MONGODB_INTERNAL_PORT=${{ secrets.MONGODB_INTERNAL_PORT }}" >> .env
        echo "QDRANT_HOST_PORT=${{ secrets.QDRANT_HOST_PORT }}" >> .env
        echo "QDRANT_INTERNAL_PORT=${{ secrets.QDRANT_INTERNAL_PORT }}" >> .env
        echo "QDRANT_GRPC_HOST_PORT=${{ secrets.QDRANT_GRPC_HOST_PORT }}" >> .env
        echo "QDRANT_GRPC_INTERNAL_PORT=${{ secrets.QDRANT_GRPC_INTERNAL_PORT }}" >> .env
        
        # Application Configuration
        echo "BASIC_LLM_PROVIDER=${{ secrets.BASIC_LLM_PROVIDER }}" >> .env
        echo "BASIC_LLM_VERSION=${{ secrets.BASIC_LLM_VERSION }}" >> .env
        echo "ADVANCED_LLM_PROVIDER=${{ secrets.ADVANCED_LLM_PROVIDER }}" >> .env
        echo "ADVANCED_LLM_VERSION=${{ secrets.ADVANCED_LLM_VERSION }}" >> .env
        echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env
        echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> .env
        echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
        echo "MODEL_PATH=${{ secrets.MODEL_PATH }}" >> .env
        echo "VECTOR_COLLECTION=${{ secrets.VECTOR_COLLECTION }}" >> .env
        
        # Database Configuration
        echo "MONGO_USERNAME=${{ secrets.MONGO_USERNAME }}" >> .env
        echo "MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}" >> .env
        echo "MONGO_DATABASE=${{ secrets.MONGO_DATABASE }}" >> .env
        
        echo "=== .env file created successfully ==="
        echo "Contents:"
        cat .env

    - name: Create docker-compose for CI
      run: |
        echo "=== Creating docker-compose.ci.yml ==="
        cat > docker-compose.ci.yml << 'EOF'
        services:
          assistant:
            build:
              context: .
              dockerfile: Dockerfile
            volumes:
              - .:/AI-Assistant:rw
              - static:/static
            ports:
              - "${FLASK_HOST_PORT}:${FLASK_INTERNAL_PORT}"
            command: >
              sh -c "
              gunicorn -w 4 --bind 0.0.0.0:${FLASK_INTERNAL_PORT} --timeout 180 --log-level debug run:app
              "
            restart: always
            depends_on:
              - qdrant
              - redis
              - mongodb
            environment:
              # LLM Configuration
              BASIC_LLM_PROVIDER: ${BASIC_LLM_PROVIDER}
              BASIC_LLM_VERSION: ${BASIC_LLM_VERSION}
              ADVANCED_LLM_PROVIDER: ${ADVANCED_LLM_PROVIDER}
              ADVANCED_LLM_VERSION: ${ADVANCED_LLM_VERSION}
              
              # API Keys
              GEMINI_API_KEY: ${GEMINI_API_KEY}
              OPENAI_API_KEY: ${OPENAI_API_KEY}
              
              # Application Configuration
              FLASK_INTERNAL_PORT: ${FLASK_INTERNAL_PORT}
              FLASK_HOST_PORT: ${FLASK_HOST_PORT}
              JWT_SECRET: ${JWT_SECRET}
              MODEL_PATH: ${MODEL_PATH}
              
              # Database Configuration
              REDIS_HOST: redis
              REDIS_INTERNAL_PORT: ${REDIS_INTERNAL_PORT}
              REDIS_URL: redis://redis:${REDIS_INTERNAL_PORT}/0

              # MongoDB Configuration
              MONGODB_HOST: mongodb
              MONGODB_INTERNAL_PORT: ${MONGODB_INTERNAL_PORT}
              MONGO_USERNAME: ${MONGO_USERNAME}
              MONGO_PASSWORD: ${MONGO_PASSWORD}
              MONGO_DATABASE: ${MONGO_DATABASE}
              MONGO_URL: "mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:${MONGODB_INTERNAL_PORT}/${MONGO_DATABASE}?authSource=admin"
              
              # Vector Database Configuration
              QDRANT_CLIENT: http://qdrant:${QDRANT_INTERNAL_PORT}
              VECTOR_COLLECTION: ${VECTOR_COLLECTION}

          qdrant:
            image: qdrant/qdrant:latest
            ports: 
              - "${QDRANT_HOST_PORT}:${QDRANT_INTERNAL_PORT}"
              - "${QDRANT_GRPC_HOST_PORT}:${QDRANT_GRPC_INTERNAL_PORT}"
            volumes:
              - vectordata:/qdrant/storage

          redis:
            image: redis:6-alpine
            restart: always
            ports:
              - "${REDIS_HOST_PORT}:${REDIS_INTERNAL_PORT}"

          mongodb:
            image: mongo:6.0
            restart: always
            ports:
              - "${MONGODB_HOST_PORT}:${MONGODB_INTERNAL_PORT}"
            environment:
              MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
              MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
              MONGO_INITDB_DATABASE: ${MONGO_DATABASE}
            volumes:
              - mongodb_data:/data/db

        volumes:
          vectordata:
          static:
          mongodb_data:
        EOF

        echo "=== docker-compose.ci.yml created successfully ==="

    - name: Build and Validate Assistant Container
      id: validate-container
      run: |
        echo "=== Building and Validating AI Assistant Service ==="
        
        # Build the image using docker compose 
        echo "=== Building Docker images ==="
        docker compose -f docker-compose.ci.yml build
        
        # Start all services
        echo "=== Starting all services with 'docker compose up' ==="
        docker compose -f docker-compose.ci.yml up -d
        
        # Wait for startup
        echo "=== Waiting 90 seconds for services to initialize ==="
        sleep 90
        
        # Check container status
        echo "=== Checking 'docker ps -a' for all containers ==="
        docker ps -a --filter "name=ai-assistant" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # Get logs and validate
        echo ""
        echo "=== Checking Assistant Container Logs ==="
        CONTAINER_NAME="ai-assistant-assistant-1"
        
        if docker ps -a --filter "name=$CONTAINER_NAME" | grep -q "$CONTAINER_NAME"; then
          echo "[SUCCESS] Container $CONTAINER_NAME exists"
          
          CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' $CONTAINER_NAME 2>/dev/null || echo "unknown")
          echo "Container status: $CONTAINER_STATUS"
          
          if [[ "$CONTAINER_STATUS" == "exited" ]]; then
            EXIT_CODE=$(docker inspect --format='{{.State.ExitCode}}' $CONTAINER_NAME)
            echo "Exit code: $EXIT_CODE"
          fi
          
          echo ""
          echo "=== Container Logs ==="
          docker logs $CONTAINER_NAME --tail 700 || echo "Could not get logs"
          
          if [[ "$CONTAINER_STATUS" == "exited" ]]; then
            echo ""
            echo "=== RESTARTING CONTAINER ==="
            docker restart $CONTAINER_NAME
            sleep 5
            echo "=== LOGS AFTER RESTART ==="
            docker logs $CONTAINER_NAME --tail 50 || echo "Could not get logs after restart"
          fi
        else
          echo "[ERROR] Container $CONTAINER_NAME does not exist"
          exit 1
        fi
        
        # Check all services are running
        echo ""
        echo "=== DOCKER COMPOSE STATUS ==="
        docker compose -f docker-compose.ci.yml ps
        
        # Test MongoDB connection
        echo ""
        echo "=== Testing MongoDB Connection ==="
        docker compose -f docker-compose.ci.yml exec -T mongodb mongosh -u ${{ secrets.MONGO_USERNAME }} -p ${{ secrets.MONGO_PASSWORD }} --authenticationDatabase admin --eval "db.runCommand({ping: 1})" ${{ secrets.MONGO_DATABASE }} || echo "MongoDB connection test failed"
        
        # Final validation
        echo ""
        echo "=== Final Validation Result ==="
        
        INFRA_RUNNING=true
        for service in qdrant redis mongodb assistant; do
          if docker compose -f docker-compose.ci.yml ps $service | grep -q "Up"; then
            echo "[SUCCESS] $service is running"
          else
            echo "[ERROR] $service is NOT running"
            INFRA_RUNNING=false
          fi
        done
        
        # Test application health
        APP_HEALTHY=true
        echo "=== Testing application health endpoint ==="

        # SET THE VARIABLE from GitHub Secret
        FLASK_HOST_PORT=${{ secrets.FLASK_HOST_PORT }}
        echo "Testing health on port: ${FLASK_HOST_PORT}"

        # Debug: Check what's actually running
        echo "=== Debug: Container port mapping ==="
        docker port ai-assistant-assistant-1

        echo "=== Debug: Testing connectivity ==="
        curl -v http://localhost:${FLASK_HOST_PORT}/ 2>&1 | head -20 || echo "Curl failed with detailed output above"

        if curl -f http://localhost:${FLASK_HOST_PORT}/health 2>/dev/null || \
          curl -f http://localhost:${FLASK_HOST_PORT}/ 2>/dev/null; then
          echo "[SUCCESS] Application is responding"
        else
          echo "[ERROR] Application is NOT responding"
          APP_HEALTHY=false
        fi
    - name: Tag and Push Image to Docker Hub
      if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && steps.validate-container.outcome == 'success'
      run: |
        echo "=== Tagging and pushing Assistant image to Docker Hub ==="
        
        # Get the built image and tag it
        IMAGE_ID=$(docker compose -f docker-compose.ci.yml images -q assistant)
        IMAGE_TAG="${{ secrets.DOCKER_HUB_USERNAME }}/ai-assistant:staging"
        
        docker tag $IMAGE_ID $IMAGE_TAG
        docker push $IMAGE_TAG
        
        echo "[SUCCESS] Image pushed successfully to Docker Hub"
        echo "Image: $IMAGE_TAG"

    - name: Set deployment trigger
      if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && steps.validate-container.outcome == 'success'
      id: deployment-trigger
      run: |
        echo "docker_pushed=true" >> $GITHUB_OUTPUT

    - name: Cleanup Docker Compose
      if: always()
      run: |
        echo "=== Cleaning up Docker Compose setup ==="
        docker compose -f docker-compose.ci.yml down -v
        rm -f docker-compose.ci.yml
        rm -f .env

    - name: Cleanup Docker system
      if: always()
      run: |
        echo "=== Cleaning up Docker system ==="
        docker system prune -f
        echo "=== Disk space after cleanup ==="
        df -h

    - name: Trigger CD workflow via Repository Dispatch
      if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && steps.validate-container.outcome == 'success'
      run: |
        curl -L -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/${{ github.repository }}/dispatches \
          -d '{"event_type":"deploy-staging","client_payload":{"image_tag":"${{ secrets.DOCKER_HUB_USERNAME }}/ai-assistant:staging"}}'
        echo "[SUCCESS] CD workflow triggered successfully!"

  validation-summary:
    runs-on: ubuntu-latest
    needs: build-and-validate-assistant
    if: always()
    steps:
    - name: Summary
      run: |
        echo "=== CI/CD Validation Summary ==="
        echo "Assistant Validation: ${{ needs.build-and-validate-assistant.outputs.validation-status }}"
        
        if [[ "${{ needs.build-and-validate-assistant.outputs.validation-status }}" == "success" ]]; then
          echo "[SUCCESS] SUCCESS: AI Assistant built, validated, and pushed to Docker Hub!"
          echo "*** Image: ${{ secrets.DOCKER_HUB_USERNAME }}/ai-assistant:staging"
        else
          echo "[ERROR] FAILED: Validation did not pass. Check the build-and-validate-assistant job for details."
          exit 1
        fi